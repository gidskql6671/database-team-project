# 동시성 제어, 디비 일관성 & 무결성 제어 방법

## POST, POST_COMMENT, RESERVED_CLASSROOM 테이블의 id 속성 값은 1씩 증가되며 들어간다.
이제껏 배웠던 방법으로는 `MAX(id) + 1`과 같은 형태로 값을 채워넣어야 한다.
하지만 트랜잭션을 사용한다 하더라도 동시에 생성을 할 경우, 같은 값이 반환될 수 있다.
물론 Primary Key 이기 때문에 중복이 불가능하여 DBMS단에서 무결성을 지켜줄 것이지만,
UX를 개선하고 DBMS에 불필요한 무결성 에러를 발생시키지 않기 위해 SEQUENCE라는 기법을 사용하였다.

## 수강 신청
### 정원을 체크하기 위한 작업
수강 신청에는 수강 정원이 있습니다.

기존 스키마 구조상으로 수강 정원이 넘는지 확인하기 위해서는 `TAKE_CLASS` 집계 함수를 사용하여 레코드 개수를 확인해야 합니다.
하지만 이 경우 트랜잭션을 사용한다 하더라도, 동시에 요청이 들어올 경우 수강 정원을 넘길 수 있습니다.
그렇기 때문에 `CLASS` 테이블에 현재 수강신청한 사용자 수를 측정하는 `Cur_student_number` 속성을 추가하고, CHECK 제약 조건을 사용해 수강 정원 이하가 되도록 설정했습니다.
그리고 트리거를 사용하여 `TAKE_CLASS`에 레코드를 추가할 때(즉, 수강 신청할 때), Cur_student_number의 값을 늘리도록 했습니다.
이럴 경우, `TAKE_CLASS` 테이블에 레코드를 추가하였는데, 수강 정원을 초과하면 롤백되어 수강 정원을 초과할 수 없게 됩니다.

반대로 `TAKE_CLASS` 테이블에서 레코드를 제거할 때는(즉 수강 신청 취소), Cur_student_number의 값을 줄여주는 트리거도 추가했습니다.

## 트랜잭션과 고립 수준
수강 신청 로직은 다음과 같이 진행된다.
(1) CLASS 테이블에서 현재 수강 신청한 사용자 수와 최대 수강 신청 가능 수를 조회하는 SELECT 구문을 호출한다.
(2) 이후 현재 수 < 최대 수라면 TAKE_CLASS 테이블에 새로운 레코드를 삽입(INSERT)한다.
(3) 이때, 트리거가 발동하여 CLASS 테이블의 현재 수강 신청한 사용자 수를 +1로 업데이트한다.
(4) 이때, CHECK 제약조건을 통해 현재 수 <= 최대 수를 만족하는지 체크한다.

이 과정에서 CLASS 테이블에 대해 SELECT와 UPDATE 구문이 호출되기에 트랜잭션으로 묶게 되었다.
또한 고립 수준은 SERIALIZABLE로 설정하였는데, CLASS 테이블의 같은 레코드에 대해서 Lock을 걸기 위함이다.
누군가가 어느 수업에 수강 신청을 하고 있는 경우, 다른 사용자가 같은 수업에 수강 신청을 시도할 경우 문제가 발생할 수 있다.
수강 신청의 경우 일관성과 무결성이 굉장히 중요한 작업이고, 또 우리 서비스는 간소화를 많이 했지만 실제 수강 신청 서비스라면 다른 로직들이 추가적으로 존재할 가능성이 매우 크다.
그렇기에 고립 수준을 SERIALIZABLE로 설정하여, 어느 사용자가 수강 신청 로직을 처리할 때는 다른 사용자가 접근할 수 없도록 만들었다.

또한 이는 수강 신청 취소의 과정에서도 같은 맥락으로 적용된다.


## 강의실 예약
### 중복 예약을 체크하기 위한 작업
강의실 예약은 8시~22시 사이의 시간을 1시간 단위로 예약이 가능하며, 동일한 시간대에는 1명만 예약이 가능합니다.
예약 시간대를 체크하기 위해 `RESERVED_CLASSROOM` 테이블에 존재하는 `start_timestamp`와 `end_timestamp` 속성을 활용하였습니다.
강의실은 각 시간대에 1명만 예약이 가능하기에 트랜잭션을 통해 동시에 예약이 들어오는 것을 방지하였습니다.

## 트랜잭션과 고립 수준
강의실 예약 로직은 다음과 같이 진행됩니다.
(1) reserved_classroom_seq Sequence를 통해 새 예약 id를 가져옵니다.
(2) 새 예약이 현재보다 이전 날짜이거나, 종료 시간이 시작 시간보다 빠르다면 오류 메시지를 반환합니다.
(3) 새 예약이 기존 예약과 중복되는지 buildingnumber, roomnumber, start_timestamp, end_timestamp를 통해 확인합니다.
(4) 중복된다면 SQL Execption을 발생 시키고, 중복되지 않는다면 RESERVED_CLASSROOM 테이블에 id와 예약정보를 새 튜플로 삽입합니다.

이 과정에서 RESERVED_CLASSROOM 테이블에 대해 SELECT와 INSERT 구문이 호출되기에 트랜잭션으로 묶게 되었습니다.
또한 고립 수준은 SERIALIZABLE로 설정하였는데, 예약 중에 RESERVED_CLASSROOM 테이블에 다른 예약이 INSERT 되는 것을 막기위함입니다.
다른 이용자가 동일한 시간대에 예약을 시도할 경우 문제가 발생할 수 있기 때문입니다.
수강 신청과 마찬가지로 강의실 예약 작업자체가 일관성과 무결성이 굉장히 중요한 작업이기 때문에 고립 수준을 SERIALIZABLE로 설정하여, 어느 사용자가 강의실 예약 로직을 처리할 때는 다른 사용자가 접근할 수 없도록 만들었습니다.
