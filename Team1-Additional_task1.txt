# 동시성 제어, 디비 일관성 & 무결성 제어 방법

## POST, POST_COMMENT, RESERVED_CLASSROOM 테이블의 id 속성 값은 1씩 증가되며 들어간다.
이제껏 배웠던 방법으로는 `MAX(id) + 1`과 같은 형태로 값을 채워넣어야 한다.
하지만 트랜잭션을 사용한다 하더라도 동시에 생성을 할 경우, 같은 값이 반환될 수 있다.
물론 Primary Key 이기 때문에 중복이 불가능하여 DBMS단에서 무결성을 지켜줄 것이지만,
UX를 개선하고 DBMS에 불필요한 무결성 에러를 발생시키지 않기 위해 SEQUENCE라는 기법을 사용하였다.

## 수강 신청
### 정원을 체크하기 위한 작업
수강 신청에는 수강 정원이 있습니다.

기존 스키마 구조상으로 수강 정원이 넘는지 확인하기 위해서는 `TAKE_CLASS` 집계 함수를 사용하여 레코드 개수를 확인해야 합니다.
하지만 이 경우 트랜잭션을 사용한다 하더라도, 동시에 요청이 들어올 경우 수강 정원을 넘길 수 있습니다.
그렇기 때문에 `CLASS` 테이블에 현재 수강신청한 사용자 수를 측정하는 `Cur_student_number` 속성을 추가하고, CHECK 제약 조건을 사용해 수강 정원 이하가 되도록 설정했습니다.
그리고 트리거를 사용하여 `TAKE_CLASS`에 레코드를 추가할 때(즉, 수강 신청할 때), Cur_student_number의 값을 늘리도록 했습니다.
이럴 경우, `TAKE_CLASS` 테이블에 레코드를 추가하였는데, 수강 정원을 초과하면 롤백되어 수강 정원을 초과할 수 없게 됩니다.

## 트랜잭션의 여부
(1) 수강 신청의 로직에서는 CLASS 테이블에서 현재 수강 신청한 사용자 수와 최대 수강 신청 가능 수를 조회하는 SELECT 구문을 호출한다.
(2) 이후 현재 수 < 최대 수라면 TAKE_CLASS 테이블에 새로운 레코드를 삽입(INSERT)한다.
(3) 이때, 트리거가 발동하여 CLASS 테이블의 현재 수강 신청한 사용자 수를 +1로 업데이트한다.
(4) 이때, CHECK 제약조건을 통해 현재 수 <= 최대 수를 만족하는지 체크한다.

이 과정에서 트랜잭션을 별도로 설정하는 것은 무의미하다고 판단하여 설정하지 않았다.
그 이유는 우선 삽입과 더불어 실행되는 트리거의 업데이트 구문(2 ~ 4)은 이미 오라클의 스펙상 한 트랜잭션으로 동작한다.
즉, 트리거의 업데이트 구문이 CHECK 제약으로 인해 실패하면, INSERT도 같이 롤백된다.

``` sql
UPDATE CLASS
SET CUR_STUDENT_NUMBER = CLASS.CUR_STUDENT_NUMBER + 1
WHERE LECTURE_CODE = :NEW.LECTURE_CODE AND SECTION_CODE = :NEW.SECTION_CODE;
```
또한 Update 구문은 atomic 하고, 트리거의 update는 위처럼 다른 구문에서 얻은 값을 업데이트에 사용하는 것이 아니기에 문제가 없다.

마지막으로 (1) 과정에서 얻은 값 역시 이후 과정의 구문들에서는 사용되지 않는다.
그렇기에 해당 과정 전체를 트랜잭션으로 걸어줄 필요가 없으며, 만약 걸어준다면 불필요한 성능의 하락을 겪기에 걸지 않았다.
auto commit을 켜놓아서, 트랜잭션은 전체로 안걸리고 각각의 과정 (1)과 (2 ~ 4)에 따로 걸린다!

또한 이는 수강 신청 취소의 과정에서도 마찬가지로 적용된다. DELETE 구문 한개가 끝이라 불필요하다.